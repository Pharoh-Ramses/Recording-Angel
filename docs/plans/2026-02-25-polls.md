# Polls Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add in-app single-choice polls as a post type, with anonymous voting, optional close dates, and results shown only after voting.

**Architecture:** Polls are a new post `type` ("poll") with two supporting tables: `pollOptions` (ordered labels) and `pollVotes` (one vote per member per poll). The existing moderation, translation, and feed pipelines are extended to handle polls. A new `PollCard` component renders inline within `PostCard`.

**Tech Stack:** Convex (schema, mutations, queries), React, Tailwind CSS, shadcn/ui, Lucide icons

---

### Task 1: Schema — Add `pollOptions` and `pollVotes` tables, extend `posts` type

**Files:**
- Modify: `apps/web/convex/schema.ts:70-95`

**Step 1: Add "poll" to the posts type union and add `pollCloseDate`**

In the `posts` table definition, update the `type` field and add the new optional field:

```typescript
type: v.union(
  v.literal("announcement"),
  v.literal("event"),
  v.literal("classifieds"),
  v.literal("poll")
),
```

Add after `eventLocation`:

```typescript
// Poll-specific fields
pollCloseDate: v.optional(v.string()),
```

**Step 2: Add `pollOptions` and `pollVotes` tables**

Add after the `comments` table definition (end of schema, before the closing `});`):

```typescript
// Poll options for poll-type posts
pollOptions: defineTable({
  postId: v.id("posts"),
  label: v.string(),
  position: v.number(),
}).index("byPostId", ["postId"]),

// Poll votes (one per member per poll)
pollVotes: defineTable({
  postId: v.id("posts"),
  optionId: v.id("pollOptions"),
  memberId: v.id("members"),
})
  .index("byPostIdAndMemberId", ["postId", "memberId"])
  .index("byOptionId", ["optionId"]),
```

**Step 3: Verify**

Run: `cd apps/web && bunx convex dev --once`
Expected: Schema push succeeds.

**Step 4: Commit**

```bash
git add apps/web/convex/schema.ts
git commit -m "feat: add pollOptions and pollVotes tables, add poll post type"
```

---

### Task 2: Backend — Update `posts.create` to handle poll options

**Files:**
- Modify: `apps/web/convex/posts.ts:11-60`

**Step 1: Update the create mutation args and handler**

In `posts.ts`, update the `create` mutation:

1. Update the `type` arg to include `"poll"`:

```typescript
type: v.union(
  v.literal("announcement"),
  v.literal("event"),
  v.literal("classifieds"),
  v.literal("poll")
),
```

2. Add new args after `eventLocation`:

```typescript
pollOptions: v.optional(v.array(v.string())),
pollCloseDate: v.optional(v.string()),
```

3. Add validation at the top of the handler (after the `getAuthenticatedMember` call):

```typescript
if (args.type === "poll") {
  if (!args.pollOptions || args.pollOptions.length < 2 || args.pollOptions.length > 6) {
    throw new Error("Polls require 2-6 options");
  }
}
```

4. Add `pollCloseDate` to the `ctx.db.insert("posts", ...)` call:

```typescript
pollCloseDate: args.type === "poll" ? args.pollCloseDate : undefined,
```

5. After the `ctx.db.insert("posts", ...)` call and before the moderation scheduling, insert poll options:

```typescript
// Insert poll options
if (args.type === "poll" && args.pollOptions) {
  for (let i = 0; i < args.pollOptions.length; i++) {
    await ctx.db.insert("pollOptions", {
      postId,
      label: args.pollOptions[i],
      position: i,
    });
  }
}
```

**Step 2: Verify**

Run: `cd apps/web && bunx convex dev --once`
Expected: Functions sync without errors.

**Step 3: Commit**

```bash
git add apps/web/convex/posts.ts
git commit -m "feat: support poll creation with options in posts.create"
```

---

### Task 3: Backend — Create `convex/polls.ts` with vote, getOptions, myVote, getResults

**Files:**
- Create: `apps/web/convex/polls.ts`

**Step 1: Create the polls module**

Create `apps/web/convex/polls.ts`:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getAuthenticatedMember } from "./lib/permissions";

export const vote = mutation({
  args: {
    postId: v.id("posts"),
    optionId: v.id("pollOptions"),
  },
  handler: async (ctx, { postId, optionId }) => {
    const post = await ctx.db.get(postId);
    if (!post || post.status !== "approved" || post.type !== "poll") {
      throw new Error("Poll not found");
    }

    // Check poll is not expired
    if (post.pollCloseDate && new Date(post.pollCloseDate) < new Date()) {
      throw new Error("Poll is closed");
    }

    const member = await getAuthenticatedMember(ctx, post.wardId);
    if (!member) throw new Error("Not an active member of this ward");

    // Check option belongs to this post
    const option = await ctx.db.get(optionId);
    if (!option || option.postId !== postId) {
      throw new Error("Invalid option");
    }

    // Check if already voted
    const existingVote = await ctx.db
      .query("pollVotes")
      .withIndex("byPostIdAndMemberId", (q) =>
        q.eq("postId", postId).eq("memberId", member._id)
      )
      .unique();

    if (existingVote) {
      throw new Error("Already voted on this poll");
    }

    await ctx.db.insert("pollVotes", {
      postId,
      optionId,
      memberId: member._id,
    });
  },
});

export const getOptions = query({
  args: { postId: v.id("posts") },
  handler: async (ctx, { postId }) => {
    const options = await ctx.db
      .query("pollOptions")
      .withIndex("byPostId", (q) => q.eq("postId", postId))
      .collect();

    return options.sort((a, b) => a.position - b.position);
  },
});

export const myVote = query({
  args: { postId: v.id("posts") },
  handler: async (ctx, { postId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const user = await ctx.db
      .query("users")
      .withIndex("byClerkId", (q) => q.eq("clerkId", identity.subject))
      .unique();
    if (!user) return null;

    // Find any active membership (we just need the memberId)
    const post = await ctx.db.get(postId);
    if (!post) return null;

    const member = await ctx.db
      .query("members")
      .withIndex("byUserIdAndWardId", (q) =>
        q.eq("userId", user._id).eq("wardId", post.wardId)
      )
      .unique();
    if (!member) return null;

    const vote = await ctx.db
      .query("pollVotes")
      .withIndex("byPostIdAndMemberId", (q) =>
        q.eq("postId", postId).eq("memberId", member._id)
      )
      .unique();

    return vote ? { optionId: vote.optionId } : null;
  },
});

export const getResults = query({
  args: { postId: v.id("posts") },
  handler: async (ctx, { postId }) => {
    const options = await ctx.db
      .query("pollOptions")
      .withIndex("byPostId", (q) => q.eq("postId", postId))
      .collect();

    const sortedOptions = options.sort((a, b) => a.position - b.position);

    const results = await Promise.all(
      sortedOptions.map(async (option) => {
        const votes = await ctx.db
          .query("pollVotes")
          .withIndex("byOptionId", (q) => q.eq("optionId", option._id))
          .collect();
        return { ...option, voteCount: votes.length };
      })
    );

    const totalVotes = results.reduce((sum, r) => sum + r.voteCount, 0);

    return { options: results, totalVotes };
  },
});
```

**Step 2: Verify**

Run: `cd apps/web && bunx convex dev --once`
Expected: Functions sync without errors.

**Step 3: Commit**

```bash
git add apps/web/convex/polls.ts
git commit -m "feat: add poll vote, getOptions, myVote, and getResults queries"
```

---

### Task 4: Backend — Cascade delete poll data on post/user deletion

**Files:**
- Modify: `apps/web/convex/users.ts` (in the `deleteByClerkId` mutation, inside the member deletion loop)

**Step 1: Delete poll votes when deleting a member**

In `users.ts`, in the `deleteByClerkId` mutation, inside the member deletion loop, after the comments deletion block and before deleting the member record, add:

```typescript
// Delete member's poll votes
const pollVotes = await ctx.db
  .query("pollVotes")
  .filter((q) => q.eq(q.field("memberId"), member._id))
  .collect();
for (const vote of pollVotes) {
  await ctx.db.delete(vote._id);
}
```

Note: Poll options are associated with posts, not members. When a member's posts are deleted (already handled above), we should also delete the poll options for those posts. Add this inside the posts deletion loop (after `await ctx.db.delete(post._id)`):

```typescript
// Delete poll options for this post
if (post.type === "poll") {
  const pollOptions = await ctx.db
    .query("pollOptions")
    .withIndex("byPostId", (q) => q.eq("postId", post._id))
    .collect();
  for (const option of pollOptions) {
    // Delete votes for this option
    const optionVotes = await ctx.db
      .query("pollVotes")
      .withIndex("byOptionId", (q) => q.eq("optionId", option._id))
      .collect();
    for (const vote of optionVotes) {
      await ctx.db.delete(vote._id);
    }
    await ctx.db.delete(option._id);
  }
}
```

**Step 2: Verify**

Run: `cd apps/web && bunx convex dev --once`
Expected: Functions sync without errors.

**Step 3: Commit**

```bash
git add apps/web/convex/users.ts
git commit -m "feat: cascade delete poll options and votes on user deletion"
```

---

### Task 5: UI — Add "Poll" to the feed filter sidebar

**Files:**
- Modify: `apps/web/components/left-sidebar.tsx:21-26`

**Step 1: Add poll filter to FEED_FILTERS**

In `left-sidebar.tsx`, update the `FEED_FILTERS` array. Add the `BarChart3` icon import to the existing lucide-react import, then add the poll filter:

Add `BarChart3` to the lucide-react import line.

Update `FEED_FILTERS`:

```typescript
const FEED_FILTERS = [
  { label: "All", value: undefined, icon: LayoutList },
  { label: "Announcements", value: "announcement", icon: Megaphone },
  { label: "Events", value: "event", icon: CalendarDays },
  { label: "Polls", value: "poll", icon: BarChart3 },
  { label: "Classifieds", value: "classifieds", icon: ShoppingBag },
] as const;
```

**Step 2: Verify**

Run: `bun run dev` — navigate to a ward page. The left sidebar should show a "Polls" filter option.

**Step 3: Commit**

```bash
git add apps/web/components/left-sidebar.tsx
git commit -m "feat: add Polls filter to left sidebar"
```

---

### Task 6: UI — Update CreatePostButton to handle poll creation

**Files:**
- Modify: `apps/web/components/create-post-button.tsx`

**Step 1: Add poll option state and UI**

Update the component:

1. Add state for poll options and close date (after existing state declarations):

```typescript
const [pollOptions, setPollOptions] = useState<string[]>(["", ""]);
const [pollCloseDate, setPollCloseDate] = useState("");
```

2. Update the `type` state type to include `"poll"`:

```typescript
const [type, setType] = useState<"announcement" | "event" | "classifieds" | "poll">(
  "announcement"
);
```

3. Update the `handleSubmit` function to pass poll args:

```typescript
async function handleSubmit() {
  if (!title.trim() || !content.trim()) return;

  if (type === "poll") {
    const validOptions = pollOptions.filter((o) => o.trim());
    if (validOptions.length < 2) return;
  }

  await createPost({
    wardId,
    type,
    title: title.trim(),
    content,
    eventDate: type === "event" ? eventDate : undefined,
    eventLocation: type === "event" ? eventLocation : undefined,
    pollOptions: type === "poll" ? pollOptions.filter((o) => o.trim()) : undefined,
    pollCloseDate: type === "poll" && pollCloseDate ? pollCloseDate : undefined,
  });

  setTitle("");
  setContent("");
  setType("announcement");
  setEventDate("");
  setEventLocation("");
  setPollOptions(["", ""]);
  setPollCloseDate("");
  setOpen(false);
}
```

4. Add `"Poll"` to the Select dropdown (after the "Classifieds" SelectItem):

```tsx
<SelectItem value="poll">Poll</SelectItem>
```

5. Add poll-specific fields after the event fields block (after the `{type === "event" && (...)}` block):

```tsx
{type === "poll" && (
  <div className="space-y-3">
    <p className="text-sm font-medium">Poll Options</p>
    {pollOptions.map((option, index) => (
      <div key={index} className="flex gap-2">
        <Input
          placeholder={`Option ${index + 1}`}
          value={option}
          onChange={(e) => {
            const updated = [...pollOptions];
            updated[index] = e.target.value;
            setPollOptions(updated);
          }}
        />
        {pollOptions.length > 2 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() =>
              setPollOptions(pollOptions.filter((_, i) => i !== index))
            }
          >
            &times;
          </Button>
        )}
      </div>
    ))}
    {pollOptions.length < 6 && (
      <Button
        variant="outline"
        size="sm"
        onClick={() => setPollOptions([...pollOptions, ""])}
      >
        Add option
      </Button>
    )}
    <Input
      type="datetime-local"
      value={pollCloseDate}
      onChange={(e) => setPollCloseDate(e.target.value)}
      placeholder="Close date (optional)"
    />
    <p className="text-xs text-muted-foreground">
      Optional: set a date when voting closes.
    </p>
  </div>
)}
```

**Step 2: Verify**

Run: `bun run dev` — open the create post dialog, select "Poll" from the type dropdown. Should see option inputs and close date picker.

**Step 3: Commit**

```bash
git add apps/web/components/create-post-button.tsx
git commit -m "feat: add poll creation UI with options and optional close date"
```

---

### Task 7: UI — Create PollCard component

**Files:**
- Create: `apps/web/components/poll-card.tsx`

**Step 1: Create the PollCard component**

Create `apps/web/components/poll-card.tsx`:

```tsx
"use client";

import { useState } from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import { cn } from "@/lib/utils";
import { Check, Clock } from "lucide-react";

interface PollCardProps {
  postId: Id<"posts">;
  pollCloseDate?: string;
  isMember?: boolean;
}

export function PollCard({ postId, pollCloseDate, isMember = true }: PollCardProps) {
  const options = useQuery(api.polls.getOptions, { postId });
  const myVote = useQuery(api.polls.myVote, { postId });
  const results = useQuery(api.polls.getResults, { postId });
  const vote = useMutation(api.polls.vote);
  const [voting, setVoting] = useState(false);

  const isExpired = pollCloseDate ? new Date(pollCloseDate) < new Date() : false;
  const hasVoted = myVote !== null && myVote !== undefined && myVote.optionId !== undefined;
  const showResults = hasVoted || isExpired;

  async function handleVote(optionId: Id<"pollOptions">) {
    if (voting || hasVoted || isExpired || !isMember) return;
    setVoting(true);
    try {
      await vote({ postId, optionId });
    } finally {
      setVoting(false);
    }
  }

  if (!options) return null;

  // Results view (after voting or expired)
  if (showResults && results) {
    return (
      <div className="mt-3 space-y-2">
        {results.options.map((option) => {
          const percentage =
            results.totalVotes > 0
              ? Math.round((option.voteCount / results.totalVotes) * 100)
              : 0;
          const isMyVote = hasVoted && myVote?.optionId === option._id;

          return (
            <div key={option._id} className="relative">
              <div className="flex items-center justify-between text-sm py-2 px-3 rounded-lg border border-border relative overflow-hidden">
                {/* Background bar */}
                <div
                  className={cn(
                    "absolute inset-0 rounded-lg transition-all",
                    isMyVote ? "bg-primary/15" : "bg-muted/50"
                  )}
                  style={{ width: `${percentage}%` }}
                />
                {/* Content */}
                <span className="relative flex items-center gap-2 font-medium">
                  {option.label}
                  {isMyVote && <Check className="h-3.5 w-3.5 text-primary" />}
                </span>
                <span className="relative text-muted-foreground text-xs">
                  {percentage}% ({option.voteCount})
                </span>
              </div>
            </div>
          );
        })}
        <PollFooter
          totalVotes={results.totalVotes}
          pollCloseDate={pollCloseDate}
          isExpired={isExpired}
        />
      </div>
    );
  }

  // Voting view (before voting)
  return (
    <div className="mt-3 space-y-2">
      {options.map((option) => (
        <button
          key={option._id}
          onClick={(e) => {
            e.stopPropagation();
            handleVote(option._id);
          }}
          disabled={voting || !isMember}
          className={cn(
            "w-full text-left text-sm py-2 px-3 rounded-lg border border-border transition-colors",
            isMember
              ? "hover:bg-accent hover:border-accent-foreground/20 cursor-pointer"
              : "opacity-60 cursor-default"
          )}
        >
          {option.label}
        </button>
      ))}
      <PollFooter
        totalVotes={results?.totalVotes ?? 0}
        pollCloseDate={pollCloseDate}
        isExpired={isExpired}
      />
    </div>
  );
}

function PollFooter({
  totalVotes,
  pollCloseDate,
  isExpired,
}: {
  totalVotes: number;
  pollCloseDate?: string;
  isExpired: boolean;
}) {
  return (
    <div className="flex items-center gap-2 text-xs text-muted-foreground pt-1">
      <span>
        {totalVotes} {totalVotes === 1 ? "vote" : "votes"}
      </span>
      {pollCloseDate && (
        <>
          <span>&middot;</span>
          <span className="flex items-center gap-1">
            <Clock className="h-3 w-3" />
            {isExpired
              ? `Closed ${new Date(pollCloseDate).toLocaleDateString(undefined, { month: "short", day: "numeric" })}`
              : `Closes ${new Date(pollCloseDate).toLocaleDateString(undefined, { month: "short", day: "numeric" })}`}
          </span>
        </>
      )}
    </div>
  );
}
```

**Step 2: Verify**

This won't render yet — it gets wired into PostCard in Task 8.

**Step 3: Commit**

```bash
git add apps/web/components/poll-card.tsx
git commit -m "feat: create PollCard component with voting and results views"
```

---

### Task 8: UI — Wire PollCard into PostCard

**Files:**
- Modify: `apps/web/components/post-card.tsx:16-28,42,82-145`

**Step 1: Add pollCloseDate to PostCardProps and pass to PollCard**

1. Add import at top of `post-card.tsx`:

```typescript
import { PollCard } from "./poll-card";
```

2. Add `pollCloseDate` to the `PostCardProps` interface:

```typescript
pollCloseDate?: string;
```

3. Add `pollCloseDate` to the destructured props:

```typescript
export function PostCard({
  postId,
  title,
  content,
  type,
  author,
  ward,
  createdAt,
  eventDate,
  eventLocation,
  preferredLanguage,
  isMember = true,
  pollCloseDate,
}: PostCardProps) {
```

4. After the event info section and before the translation indicator, add the poll card:

```tsx
{/* Poll */}
{type === "poll" && (
  <PollCard postId={postId} pollCloseDate={pollCloseDate} isMember={isMember} />
)}
```

**Step 2: Update Feed to pass pollCloseDate to PostCard**

In `apps/web/components/feed.tsx`, add `pollCloseDate` to the PostCard rendering (after `isMember`):

```tsx
pollCloseDate={post.pollCloseDate}
```

**Step 3: Verify**

Run: `bun run dev` — create a poll post, verify it appears in the feed with voting options.

**Step 4: Commit**

```bash
git add apps/web/components/post-card.tsx apps/web/components/feed.tsx
git commit -m "feat: render PollCard inline in PostCard for poll-type posts"
```

---

### Task 9: Backend — Update translation action to handle poll options

**Files:**
- Modify: `apps/web/convex/schema.ts:109-117` (postTranslations table)
- Modify: `apps/web/convex/translations.ts:85-175`

**Step 1: Add pollOptionLabels to postTranslations table**

In `schema.ts`, update the `postTranslations` table to include an optional field for translated poll option labels:

```typescript
postTranslations: defineTable({
  postId: v.id("posts"),
  language: v.string(),
  title: v.string(),
  content: v.string(),
  eventLocation: v.optional(v.string()),
  pollOptionLabels: v.optional(v.array(v.string())),
})
  .index("byPostId", ["postId"])
  .index("byPostIdAndLanguage", ["postId", "language"]),
```

**Step 2: Update saveTranslation to accept pollOptionLabels**

In `translations.ts`, update the `saveTranslation` args and handler:

```typescript
export const saveTranslation = internalMutation({
  args: {
    postId: v.id("posts"),
    language: v.string(),
    title: v.string(),
    content: v.string(),
    eventLocation: v.optional(v.string()),
    pollOptionLabels: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("postTranslations")
      .withIndex("byPostIdAndLanguage", (q) =>
        q.eq("postId", args.postId).eq("language", args.language)
      )
      .unique();

    if (existing) {
      await ctx.db.replace(existing._id, args);
    } else {
      await ctx.db.insert("postTranslations", args);
    }
  },
});
```

**Step 3: Update translatePost action to fetch and translate poll options**

In `translations.ts`, update the `translatePost` action. After fetching the post, also fetch poll options if it's a poll:

Add a new internalQuery to fetch poll options (add after `getStakeLanguages`):

```typescript
export const getPollOptionsForTranslation = internalQuery({
  args: { postId: v.id("posts") },
  handler: async (ctx, { postId }) => {
    const options = await ctx.db
      .query("pollOptions")
      .withIndex("byPostId", (q) => q.eq("postId", postId))
      .collect();
    return options.sort((a, b) => a.position - b.position);
  },
});
```

In the `translatePost` handler, after fetching the post and before the translation loop, add:

```typescript
// Fetch poll options if this is a poll
let pollOptionLabels: string[] = [];
if (post.type === "poll") {
  const pollOptions = await ctx.runQuery(
    internal.translations.getPollOptionsForTranslation,
    { postId }
  );
  pollOptionLabels = pollOptions.map((o) => o.label);
}
```

Update the system prompt construction inside the translation loop to include poll options when present:

```typescript
const systemPrompt = [
  `You are a professional translator. Translate the following content from ${sourceName} to ${targetName}.`,
  `Preserve all HTML tags exactly as they are — only translate the text content within them.`,
  `Return a JSON object with the following fields:`,
  `  - "title": the translated title`,
  `  - "content": the translated content (HTML preserved)`,
  ...(post.eventLocation
    ? [`  - "eventLocation": the translated event location`]
    : []),
  ...(pollOptionLabels.length > 0
    ? [`  - "pollOptionLabels": an array of translated poll option labels, in the same order as provided`]
    : []),
].join("\n");

const userContent = [
  `Title: ${post.title}`,
  `Content: ${post.content}`,
  ...(post.eventLocation
    ? [`Event Location: ${post.eventLocation}`]
    : []),
  ...(pollOptionLabels.length > 0
    ? [`Poll Options: ${JSON.stringify(pollOptionLabels)}`]
    : []),
].join("\n\n");
```

Update the `saveTranslation` call to include poll option labels:

```typescript
await ctx.runMutation(internal.translations.saveTranslation, {
  postId,
  language: targetLanguage,
  title: result.title,
  content: result.content,
  ...(result.eventLocation
    ? { eventLocation: result.eventLocation }
    : {}),
  ...(result.pollOptionLabels
    ? { pollOptionLabels: result.pollOptionLabels }
    : {}),
});
```

**Step 4: Verify**

Run: `cd apps/web && bunx convex dev --once`
Expected: Schema and functions sync without errors.

**Step 5: Commit**

```bash
git add apps/web/convex/schema.ts apps/web/convex/translations.ts
git commit -m "feat: translate poll option labels alongside post content"
```

---

### Task 10: Verify end-to-end flow

**No files changed — manual verification only.**

**Step 1: Test poll creation**

1. Run `bun run dev`
2. Navigate to a ward where you're a member
3. Click "What's on your mind?" → select "Poll" type
4. Fill in title, description, 3 options, optional close date
5. Submit → poll should appear in feed after moderation

**Step 2: Test voting**

1. Click an option on the poll → vote is cast
2. Results bar chart appears with your vote highlighted
3. Refresh → results persist, voting UI does not reappear

**Step 3: Test visitor behavior**

1. Navigate to a ward where you're NOT a member
2. Poll options should appear but be disabled (can't vote)

**Step 4: Test expired poll**

1. Create a poll with a close date in the past
2. After approval, results should show to everyone

**Step 5: Test sidebar filter**

1. Click "Polls" in the left sidebar → only poll posts shown

---

## Summary of Files Changed

| File | Action | Purpose |
|------|--------|---------|
| `convex/schema.ts` | Modify | Add `pollOptions`, `pollVotes` tables; add `"poll"` type and `pollCloseDate` to posts; add `pollOptionLabels` to postTranslations |
| `convex/posts.ts` | Modify | Handle poll options in `create` mutation |
| `convex/polls.ts` | Create | `vote`, `getOptions`, `myVote`, `getResults` |
| `convex/users.ts` | Modify | Cascade delete poll data on user deletion |
| `convex/translations.ts` | Modify | Translate poll option labels |
| `components/left-sidebar.tsx` | Modify | Add "Polls" feed filter |
| `components/create-post-button.tsx` | Modify | Poll creation UI (options + close date) |
| `components/poll-card.tsx` | Create | Inline poll voting/results UI |
| `components/post-card.tsx` | Modify | Render PollCard for poll-type posts |
| `components/feed.tsx` | Modify | Pass `pollCloseDate` to PostCard |
