---
phase: 03-member-enrollment
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/backend/convex/stakes.ts
  - packages/backend/convex/wards.ts
  - packages/backend/convex/memberships.ts
autonomous: true
---

<objective>
Create search queries for stakes/wards and membership mutations (join, leave, list).

Purpose: Backend functions for member enrollment flow
Output: stakes.search, wards.searchByStake queries + memberships.ts module with joinWard, leaveWard, myMemberships
</objective>

<context>
@.planning/phases/03-member-enrollment/03-RESEARCH.md
@packages/backend/convex/stakes.ts
@packages/backend/convex/wards.ts
@packages/backend/convex/lib/auth.ts
@packages/backend/convex/schema.ts
</context>

<tasks>

<task type="code">
  <name>Task 1: Add search query to stakes.ts</name>
  <file>packages/backend/convex/stakes.ts</file>
  <action>
Add a `search` public query that accepts `{ query: v.string() }`. When query is empty/whitespace, return all stakes via `.query("stakes").collect()`. When query has content, use `.withSearchIndex("search_name", q => q.search("name", args.query)).take(20)`.
  </action>
</task>

<task type="code">
  <name>Task 2: Add searchByStake query to wards.ts</name>
  <file>packages/backend/convex/wards.ts</file>
  <action>
Add a `searchByStake` public query that accepts `{ stakeId: v.id("stakes"), query: v.string() }`. When query is empty, use existing `by_stake` index to list all wards. When query has content, use `.withSearchIndex("search_name", q => q.search("name", args.query).eq("stakeId", args.stakeId)).take(20)`.
  </action>
</task>

<task type="code">
  <name>Task 3: Create memberships.ts module</name>
  <file>packages/backend/convex/memberships.ts</file>
  <action>
Create a new `memberships.ts` file with three functions:

1. `joinWard` (userMutation): Accepts `{ wardId: v.id("wards") }`. Validates ward exists, checks for existing ward membership via `by_user_org` index, creates ward membership with `role: "member"`, auto-creates parent stake membership if not present. Returns `{ wardId, stakeId }`.

2. `leaveWard` (userMutation): Accepts `{ wardId: v.id("wards") }`. Finds membership via `by_user_org` index, prevents leaders from leaving, deletes membership.

3. `myMemberships` (userQuery): No args. Queries all memberships for current user via `by_user` index. Resolves org details (stake name for stake memberships, ward name + parent stake for ward memberships). Filters out any with null orgs.

Import `userMutation` and `userQuery` from `./lib/auth`. Import `Id` type from `./_generated/dataModel`.
  </action>
</task>

<task type="verify">
  <name>Task 4: Verify TypeScript compilation</name>
  <action>Run `npx tsc --noEmit` in packages/backend to verify all files compile correctly.</action>
</task>

</tasks>

<verification>
- `stakes.search` returns all stakes for empty query, filtered results for non-empty
- `wards.searchByStake` returns wards within a stake, filtered by name
- `memberships.joinWard` atomically creates ward + stake memberships
- `memberships.leaveWard` prevents leaders from leaving
- `memberships.myMemberships` returns enriched membership data
- All functions compile without TypeScript errors
</verification>

<success_criteria>
- 2 new search queries (stakes.search, wards.searchByStake)
- 3 new membership functions (joinWard, leaveWard, myMemberships)
- No TypeScript compilation errors
</success_criteria>
