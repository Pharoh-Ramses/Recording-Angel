---
phase: 02-org-structure-languages
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - apps/web/convex/stakes.ts
  - apps/web/convex/wards.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can create a stake and becomes its leader"
    - "Stake leader can create a ward under their stake"
    - "Stakes and wards can have languages set to en and/or es"
    - "Wards inherit stake languages when not explicitly set"
  artifacts:
    - path: "apps/web/convex/stakes.ts"
      provides: "Stake CRUD operations"
      exports: ["create", "list", "get", "setLanguages"]
    - path: "apps/web/convex/wards.ts"
      provides: "Ward CRUD operations"
      exports: ["create", "listByStake", "get", "setLanguages"]
  key_links:
    - from: "apps/web/convex/stakes.ts"
      to: "memberships table"
      via: "insert leader membership on create"
      pattern: 'insert\\("memberships"'
    - from: "apps/web/convex/wards.ts"
      to: "stakeLeaderMutation"
      via: "authorization check"
      pattern: "stakeLeaderMutation"
---

<objective>
Implement stake and ward mutations/queries that satisfy ORG-01, ORG-02, ORG-03 requirements.

Purpose: Enable leaders to create and manage org structure with language settings
Output: Complete Convex functions for stake/ward CRUD operations
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-org-structure-languages/02-RESEARCH.md
@apps/web/convex/schema.ts
@apps/web/convex/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stake mutations and queries</name>
  <files>apps/web/convex/stakes.ts</files>
  <action>
Create stakes.ts with CRUD operations:

```typescript
import { v } from "convex/values";
import { query } from "./_generated/server";
import { userMutation, userQuery } from "./lib/auth";

// Language type for reuse
const languageValidator = v.union(v.literal("en"), v.literal("es"));

// Create a new stake - any authenticated user can create one
// Creator automatically becomes a stake leader
export const create = userMutation({
  args: {
    name: v.string(),
    supportedLanguages: v.array(languageValidator),
  },
  handler: async (ctx, args) => {
    // Validate languages array is not empty
    if (args.supportedLanguages.length === 0) {
      throw new Error("At least one supported language is required");
    }

    // Create the stake
    const stakeId = await ctx.db.insert("stakes", {
      name: args.name,
      supportedLanguages: args.supportedLanguages,
      createdBy: ctx.user._id,
    });

    // Make creator a leader of this stake
    await ctx.db.insert("memberships", {
      userId: ctx.user._id,
      orgType: "stake",
      orgId: stakeId,
      role: "leader",
    });

    return stakeId;
  },
});

// List all stakes (for discovery/search)
// TODO: Add pagination for production scale
export const list = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("stakes").collect();
  },
});

// List stakes where current user is a leader
export const listMyStakes = userQuery({
  args: {},
  handler: async (ctx) => {
    // Get all stake memberships for this user where they're a leader
    const memberships = await ctx.db
      .query("memberships")
      .withIndex("by_user", (q) => q.eq("userId", ctx.user._id))
      .filter((q) => q.and(
        q.eq(q.field("orgType"), "stake"),
        q.eq(q.field("role"), "leader")
      ))
      .collect();

    // Fetch the actual stake documents
    const stakes = await Promise.all(
      memberships.map((m) => ctx.db.get(m.orgId as any))
    );

    return stakes.filter(Boolean);
  },
});

// Get a single stake by ID
export const get = query({
  args: { stakeId: v.id("stakes") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.stakeId);
  },
});

// Set supported languages for a stake
// Requires stake leader role (checked via membership)
export const setLanguages = userMutation({
  args: {
    stakeId: v.id("stakes"),
    languages: v.array(languageValidator),
  },
  handler: async (ctx, args) => {
    // Validate languages array is not empty
    if (args.languages.length === 0) {
      throw new Error("At least one supported language is required");
    }

    // Check if user is a leader of this stake
    const membership = await ctx.db
      .query("memberships")
      .withIndex("by_org", (q) => q.eq("orgType", "stake").eq("orgId", args.stakeId))
      .filter((q) => q.and(
        q.eq(q.field("userId"), ctx.user._id),
        q.eq(q.field("role"), "leader")
      ))
      .unique();

    if (!membership) {
      throw new Error("Forbidden: You must be a stake leader to change languages");
    }

    await ctx.db.patch(args.stakeId, {
      supportedLanguages: args.languages,
    });
  },
});
```

Key behaviors:
- `create`: Any authenticated user can create a stake, becomes leader
- `list`: Public listing for stake discovery
- `listMyStakes`: User's stakes where they are leader
- `get`: Single stake lookup
- `setLanguages`: Restricted to stake leaders
  </action>
  <verify>
- `cat apps/web/convex/stakes.ts` shows all 5 exports
- create mutation inserts both stake and membership
- setLanguages checks leader role before patching
  </verify>
  <done>Stake CRUD with leadership and language management</done>
</task>

<task type="auto">
  <name>Task 2: Create ward mutations and queries</name>
  <files>apps/web/convex/wards.ts</files>
  <action>
Create wards.ts with CRUD operations:

```typescript
import { v } from "convex/values";
import { query } from "./_generated/server";
import { userMutation, stakeLeaderMutation } from "./lib/auth";

// Language type for reuse
const languageValidator = v.union(v.literal("en"), v.literal("es"));

// Create a new ward under a stake
// Requires stake leader role (via stakeLeaderMutation)
export const create = stakeLeaderMutation({
  args: {
    name: v.string(),
    supportedLanguages: v.optional(v.array(languageValidator)),
  },
  handler: async (ctx, args) => {
    // Create the ward
    const wardId = await ctx.db.insert("wards", {
      name: args.name,
      stakeId: ctx.stakeId,
      supportedLanguages: args.supportedLanguages,
      createdBy: ctx.user._id,
    });

    // Make creator a leader of this ward
    await ctx.db.insert("memberships", {
      userId: ctx.user._id,
      orgType: "ward",
      orgId: wardId,
      role: "leader",
    });

    return wardId;
  },
});

// List wards under a stake
export const listByStake = query({
  args: { stakeId: v.id("stakes") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("wards")
      .withIndex("by_stake", (q) => q.eq("stakeId", args.stakeId))
      .collect();
  },
});

// Get a single ward with its effective languages
// Returns ward with languages (own or inherited from stake)
export const get = query({
  args: { wardId: v.id("wards") },
  handler: async (ctx, args) => {
    const ward = await ctx.db.get(args.wardId);
    if (!ward) return null;

    // Get stake for language inheritance
    const stake = await ctx.db.get(ward.stakeId);
    
    return {
      ...ward,
      // Effective languages: ward's own or inherited from stake
      effectiveLanguages: ward.supportedLanguages ?? stake?.supportedLanguages ?? ["en"],
    };
  },
});

// Set supported languages for a ward
// Requires being a leader of either the ward OR its parent stake
export const setLanguages = userMutation({
  args: {
    wardId: v.id("wards"),
    languages: v.optional(v.array(languageValidator)),
  },
  handler: async (ctx, args) => {
    const ward = await ctx.db.get(args.wardId);
    if (!ward) {
      throw new Error("Ward not found");
    }

    // Check if user is a leader of this ward OR its stake
    const wardMembership = await ctx.db
      .query("memberships")
      .withIndex("by_org", (q) => q.eq("orgType", "ward").eq("orgId", args.wardId))
      .filter((q) => q.and(
        q.eq(q.field("userId"), ctx.user._id),
        q.eq(q.field("role"), "leader")
      ))
      .unique();

    const stakeMembership = await ctx.db
      .query("memberships")
      .withIndex("by_org", (q) => q.eq("orgType", "stake").eq("orgId", ward.stakeId))
      .filter((q) => q.and(
        q.eq(q.field("userId"), ctx.user._id),
        q.eq(q.field("role"), "leader")
      ))
      .unique();

    if (!wardMembership && !stakeMembership) {
      throw new Error("Forbidden: You must be a ward or stake leader to change languages");
    }

    // null/undefined = inherit from stake, array = explicit setting
    await ctx.db.patch(args.wardId, {
      supportedLanguages: args.languages,
    });
  },
});
```

Key behaviors:
- `create`: Only stake leaders can create wards (via stakeLeaderMutation)
- `listByStake`: Uses index for efficient stake-based filtering
- `get`: Returns ward with effectiveLanguages (inheritance fallback)
- `setLanguages`: Both ward and stake leaders can modify
  </action>
  <verify>
- `cat apps/web/convex/wards.ts` shows all 4 exports
- create uses stakeLeaderMutation for authorization
- get returns effectiveLanguages with stake fallback
- setLanguages allows both ward and stake leaders
  </verify>
  <done>Ward CRUD with stake hierarchy and language inheritance</done>
</task>

</tasks>

<verification>
1. `ls apps/web/convex/stakes.ts apps/web/convex/wards.ts` - both files exist
2. `grep "userMutation\|stakeLeaderMutation" apps/web/convex/stakes.ts apps/web/convex/wards.ts` - auth wrappers used
3. `grep "memberships" apps/web/convex/stakes.ts apps/web/convex/wards.ts` - both create leadership memberships
4. `grep "effectiveLanguages" apps/web/convex/wards.ts` - language inheritance implemented

Runtime verification requires Convex dev server.
</verification>

<success_criteria>
- stakes.ts: create, list, listMyStakes, get, setLanguages
- wards.ts: create, listByStake, get, setLanguages
- Stake creation makes user a leader (ORG-01)
- Ward creation requires stake leader role (ORG-02)
- Both can set languages en/es (ORG-03)
- Ward inherits stake languages when not set
</success_criteria>

<output>
After completion, create `.planning/phases/02-org-structure-languages/02-03-SUMMARY.md`
</output>
