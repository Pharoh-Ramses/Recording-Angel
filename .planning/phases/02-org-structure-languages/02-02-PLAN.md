---
phase: 02-org-structure-languages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/convex/lib/auth.ts
  - apps/web/convex/users.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated users can be looked up by tokenIdentifier"
    - "Unauthenticated requests throw clear error"
    - "User document is created/updated on login"
  artifacts:
    - path: "apps/web/convex/lib/auth.ts"
      provides: "Custom auth functions (userMutation, userQuery)"
      exports: ["userMutation", "userQuery", "getCurrentUser"]
    - path: "apps/web/convex/users.ts"
      provides: "User store mutation"
      exports: ["store"]
  key_links:
    - from: "apps/web/convex/lib/auth.ts"
      to: "ctx.auth.getUserIdentity()"
      via: "Convex auth context"
      pattern: "getUserIdentity"
---

<objective>
Create authenticated Convex functions with user storage - the building blocks for all protected mutations/queries.

Purpose: Enable auth-protected database operations linked to WorkOS identities
Output: Reusable custom function wrappers and user store mutation
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-org-structure-languages/02-RESEARCH.md
@apps/web/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom auth function wrappers</name>
  <files>apps/web/convex/lib/auth.ts</files>
  <action>
Create the lib/ directory and auth.ts with custom function wrappers:

```typescript
import { customMutation, customQuery } from "convex-helpers/server/customFunctions";
import { mutation, query, QueryCtx, MutationCtx } from "../_generated/server";
import { v } from "convex/values";
import { Doc } from "../_generated/dataModel";

// Get current user from WorkOS identity token
export async function getCurrentUser(ctx: QueryCtx | MutationCtx): Promise<Doc<"users"> | null> {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) return null;
  
  return await ctx.db
    .query("users")
    .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
    .unique();
}

// Type for context with user injected
type AuthenticatedCtx<Ctx> = Ctx & { user: Doc<"users"> };

// Authenticated mutation - requires logged-in user with user doc
export const userMutation = customMutation(mutation, {
  args: {},
  input: async (ctx, args) => {
    const user = await getCurrentUser(ctx);
    if (!user) {
      throw new Error("Unauthenticated: Please sign in to continue");
    }
    return { ctx: { ...ctx, user } as AuthenticatedCtx<typeof ctx>, args };
  },
});

// Authenticated query - requires logged-in user with user doc
export const userQuery = customQuery(query, {
  args: {},
  input: async (ctx, args) => {
    const user = await getCurrentUser(ctx);
    if (!user) {
      throw new Error("Unauthenticated: Please sign in to continue");
    }
    return { ctx: { ...ctx, user } as AuthenticatedCtx<typeof ctx>, args };
  },
});

// Stake leader mutation - requires stake leader role
// Used by: ward creation, stake settings
export const stakeLeaderMutation = customMutation(mutation, {
  args: { stakeId: v.id("stakes") },
  input: async (ctx, { stakeId, ...rest }) => {
    const user = await getCurrentUser(ctx);
    if (!user) {
      throw new Error("Unauthenticated: Please sign in to continue");
    }

    // Check if user is a leader of this stake
    const membership = await ctx.db
      .query("memberships")
      .withIndex("by_org", (q) => q.eq("orgType", "stake").eq("orgId", stakeId))
      .filter((q) => q.and(
        q.eq(q.field("userId"), user._id),
        q.eq(q.field("role"), "leader")
      ))
      .unique();

    if (!membership) {
      throw new Error("Forbidden: You must be a stake leader to perform this action");
    }

    return { 
      ctx: { ...ctx, user, stakeId } as AuthenticatedCtx<typeof ctx> & { stakeId: typeof stakeId }, 
      args: rest 
    };
  },
});
```

NOTE: This requires convex-helpers package. Add it in the same task:

```bash
cd apps/web
pnpm add convex-helpers
```
  </action>
  <verify>
- `ls apps/web/convex/lib/` shows auth.ts
- `pnpm ls convex-helpers` shows package installed
- File exports userMutation, userQuery, stakeLeaderMutation, getCurrentUser
  </verify>
  <done>Custom auth wrappers created with convex-helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create user store mutation</name>
  <files>apps/web/convex/users.ts</files>
  <action>
Create users.ts with the store mutation that runs on every login:

```typescript
import { mutation, query } from "./_generated/server";
import { getCurrentUser } from "./lib/auth";

// Store user in database on login
// Called by ConvexClientProvider when user authenticates
export const store = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Called store without authentication");
    }

    // Check if user already exists
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .unique();

    if (existingUser !== null) {
      // Update name if changed (email from WorkOS, name from profile)
      const name = identity.name ?? identity.email ?? "User";
      if (existingUser.name !== name) {
        await ctx.db.patch(existingUser._id, { name });
      }
      return existingUser._id;
    }

    // Create new user
    return await ctx.db.insert("users", {
      name: identity.name ?? identity.email ?? "User",
      email: identity.email ?? "",
      tokenIdentifier: identity.tokenIdentifier,
    });
  },
});

// Get current user document (for client-side use)
export const me = query({
  args: {},
  handler: async (ctx) => {
    return await getCurrentUser(ctx);
  },
});
```

Key behaviors:
- `store`: Called on each login, creates user if new, updates name if changed
- `me`: Returns current user document or null
- Uses tokenIdentifier index for efficient lookups
  </action>
  <verify>
- `cat apps/web/convex/users.ts` shows store and me exports
- store mutation handles both create and update cases
  </verify>
  <done>User store mutation handles login sync between WorkOS and Convex</done>
</task>

</tasks>

<verification>
1. `ls apps/web/convex/lib/auth.ts apps/web/convex/users.ts` - both files exist
2. `grep -l "userMutation\|userQuery" apps/web/convex/lib/auth.ts` - exports custom functions
3. `grep -l "store" apps/web/convex/users.ts` - has store mutation
4. `pnpm ls convex-helpers` - package installed

Note: Runtime verification requires Convex dev server running.
</verification>

<success_criteria>
- convex-helpers installed
- lib/auth.ts exports userMutation, userQuery, stakeLeaderMutation
- users.ts exports store mutation for login sync
- getCurrentUser function available for other modules
</success_criteria>

<output>
After completion, create `.planning/phases/02-org-structure-languages/02-02-SUMMARY.md`
</output>
